JavaScript的对象
=================
### 属性


====================

### 创建对象
#### 工厂模式

  function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
      alert(this.name);
    };
    return o;
  }
  var person1 = createPerson("Nicholas", 29, "Software Engineer");
  
缺点：不能识别对象类型。
  
#### 构造函数模式

  function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
      alert(this.name);
    };
  }
  var person1 = new Person("Nicholas", 29, "Software Engineer");  // 作为构造函数使用
  Person("Greg", 27, "Doctor"); // 作普通函数使用，添加到 window
  
与工厂模式有三点不同：
* 没有显式地创建对象
* 直接将属性和方法赋给了 this 对象
* 没有 return 语句

构造函数仍然是函数，同时一般类名第一个字母大写。可用`person1.constructor == Person`和`person instanceof Person`
判断对象类型，后者更可靠。

  // 在另一个对象的作用域中调用，
  // <a href="http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html">call()或者apply()</a>
  var o = new Object();
  Person.call(o, "Kristen", 25, "Nurse");
  o.sayName(); //"Kristen"
  
构造函数存在的问题：类的函数，每创建一个对象都要开辟空间给该函数，这是不必要的，可以把函数写到全局。

  function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
  }
  function sayName(){
    alert(this.name);
  }
  
但是，这样封装性很不好，采原型模式。

#### 原型模式
