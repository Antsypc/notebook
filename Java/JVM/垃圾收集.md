内存分配与垃圾回收策略
======================
关注的是,运行时动态分配对象内存的Java堆和方法区的内存回收.

## 垃圾收集清理的时机
### 引用计数算法
JVM未采用这种方法.虽然简单高效,但是不能不能解决循环引用的问题:两对象互相引用,再把两对象赋null,最终虽然对象已经不使用了,但是内部变量还有引用导致不能回收.

### 可达性分析算法
通过一系列'GC Roots'的对象为起点,向下搜索对象,如果对象不可达则被回收.扫描两次后仍然存在则被回收.第一次,如果没有引用且finalize()未被执行则放入F-Queue队列.第二次,执行finalize(),如果该方法对象把自己再次赋值给其他变量产生引用,则移除队列.之后如果还在队列中则被回收.

GC Roots对象包括:
- 虚拟机栈(本地变量表)中的引用的对象
- 方法区中类静态属性引用的对象
- 方法区中变量引用的对象
- native方法中JNI引用的对象

引用分为四种
- 强引用: `Object obj = new Object()`,垃圾回收器永远不会回收.
- 软引用:有用但非必须的,将要发生内存溢出时才回收,如果回收后内存还是不够,才报错.
- 弱引用:一定回收.
- 虚引用:唯一作用是,被回收时收到一个系统通知.

## 垃圾清理算法
- 标记-清理算法:垃圾清理的主要思路,存在的问题在于标记和清理两个阶段的效率低,以及产生大量空间碎片引起下次大对象空间不够再次触发垃圾回收动作.下面其他算法都是根据这种思路,针对各种情况的优化.
- 复制算法:把内存分块,一块内存使用完后把所有存活的对象复制到另一块上,然后一次性清除该块.好处:提高效率.新生代对象98%是很快要被回收,这部分的Eden空间要比Survivor空间大很多倍.
- 标记-整理算法:标记过程与"标记-清理算法"过程一致,需要回收时就把堆上的还存活的块向一端复制,移动堆顶指针,一次性清理边界外的内存.针对老年代,因为老年代存活率高,如果一次性复制一块那会复制很多的,效率低.
- 分代收集算法:根据对象存活周期不同分为新生代和老年代.新生代每次回收存活少,采用复制算法.老年代采用"标记-清理"或"标记-整理"算法.


## 内存分配
- 对象优先分配在Eden区,该区内存不够用时,进行 Minor GC.
- 大对象直接进入老年代区.比如长字符串及大数组.
- 长期存活的对象进入老年代.
- 不一定需要对象年龄达到MaxTenuringThreshold才进入老年代,如果Survivor空间相同年龄对象大小总和大于Survivor空间一半,大于等于该年龄的对象进入老年代.