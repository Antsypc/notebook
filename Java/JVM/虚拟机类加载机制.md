虚拟机类加载机制
=================

## 加载时机
- new对象,读写类的静态字段
- 反射调用
- **使用子类前必须完成所有父类的初始化**
- 虚拟机启动时,必先初始化主类(main方法)
- JDK 1.7中动态语言

接口
- 初始化过程只有一点与类不同:接口在初始化时不要求父接口全部初始化完成,只有在使用父接口时才会初始化.

额外说明:
- 通过子类直接引用父类的静态变量,只会初始化父类,不会初始化该子类.
- 在声明对象数组时,并不会引起对象的初始化,但是会有数组对象的初始化过程.数组是特殊的对象,有length等public的域可以引用.


## 类加载过程
包括加载,验证,准备,解析,初始化过程.

- 加载:读class文件等.
- 验证:文件格式,元数据,字节码,符号引用等.
- 准备:**给类变量(static)分配内存并赋零值**,如果是final则会初始化为设定的实际值.
    注意:真正的值是使用类变量时才赋值.实例变量在对象实例化时随之分配在堆中.
- 解析:虚拟机将常量池内的符号引用替换为直接引用的过程.
- 初始化:static域和代码块是**依次执行**的.静态代码块不能访问声明在其后的变量,却可以给他赋值.


## 类加载器
可自定义实现在Java虚拟机外部获取一个类:通过类的全限定名来获取描述此类的二进制字节流.

**任何一个类的唯一性是由,类本身和类加载器共同确立的**.也就是说即使是同一个类,但是使用不同的类加载器加载来使用,也是不同的类,在用equals,isInstance,instanceof判断时不相等.


## 双亲委派模型
Java虚拟机的两种类加载器,一种是虚拟机自身的启动类加载器,一种是虚拟机外部的Java语言实现的其他类加载器.

类加载器的层次依次是:
- 启动类加载器:加载`$JAVA_HOME/lib`,或`-Xbootclasspath`指定路径,且被VM按文件名识别的类库加载到虚拟机内存.不能直接使用.
- 扩展类加载器:加载`$JAVA_HOME/lib/ext`,或`java.ext.dirs`系统变量指定的路径的类.开发者可直接使用该加载器.
- 应用程序类加载器:是`ClassLoader`的`getSystemClassLoader()`的返回值,加载用户类路径的指定类库.可直接使用该加载器.
- 各种自定义类加载器

双亲委派模型是指:一个类加载器收到类加载请求,先交给父类加载器,如果父类加载器报ClassNotFoundException,再调用自己的加载方法.由此可以看出,每个类加载时都会到达顶层的启动类加载器,同时,这种加载优先级保证了同一个类有唯一的识别.比如Object类出现多种类加载实例,就很混乱了,这种保证了稳定性.