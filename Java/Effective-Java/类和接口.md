类和接口
====

## 类和成员的可访问性最小化
面向对象很重要的一点就是封装.需要暴露给外部的接口(方法和域)才暴露,一旦把API暴露给客户端,
在后期的版本迭代中就需要考虑兼容.所以,除非必要都应该把方法和域设为包级私有.
减少外部对内部不必要的访问,还能解耦,使各模块更灵活的开发.

- 尽可能使每个类和成员不能被外部访问.
- 实例域绝不能是共有的.
- 包含共有可变域的类不是线程安全的.
- 不应该有共有数组域,或提供该域的访问方法,因为客户端得到后能直接修改值,这是不可控的.就算是共有静态final也不行(一样可以修改数组内部的值).

## public类应使用public访问方法而非public域
如果域是不可变的,可以变为共有域,否则一定不要设置为共有.

如果一个类是包级私有的,只有本包可见,那么一般来说,他的域使用默认就可以了,没必要再是 private.    

## 使可变性变小
不可变类是指实例不可修改的类,虽然不可能所有的类都是 final 的,
但是由于类的可变性越小,带来的好处越多,所以最好根据实际情况尽可能遵循如下规则:
- 不提供修改对象状态的方法.
- 使类不可被扩展.加 final 修饰符.
- final 域.
- 可变组件需要互斥访问.如果类本身有可变的域,不能提供该域的外界访问方法.如果需要外部对象传入构造方法,那就使用对象拷贝,不要直接使用引用.

`BigInteger`,`BigDecimal` 内部的域都是final的,需要做运算时,把运算结果作为一个新对象返回,而不修改自身的值.

不可变对象本质上是线程安全的,不需要同步.可被自由的分享,不需要拷贝使用.

他的缺点在于,每个不同的值都需要一个不同的对象,可能带来性能问题.比如 BigInteger 现在有上百万位的数字,需要做模指数等有很多中间步骤的计算,
这时,每一步计算都产生一个百万位的 BigInteger 代价是很高的.这时,需要我们预先估计多步骤计算的需求,再设置一个包级私有的成员类,
辅助做这样一个计算就 OK 了.如今的 BigInteger 也确实是这样做的.类似的还有 String 之于 StringBuilder.

让类不能扩展,即没有子类,除了使用 final 修饰,还可以将构造方法改为 private.使用静态工厂代替共有构造方法.


## 复合优先于继承
通过继承而不是接口,会破坏封装性,父类的改变可能会破坏子类的行为,所以子类必须随父类的改变而改变.
尤其是跨包继承,这时,潜在问题很难去查找.
- 父类方法行为改变
- 父类增加了方法,不巧,子类也有同名同参数,只是返回类型不同,编译是不过的.要哭...
- 等等...

当然,如果是同一个包中,使用继承应该还是比较容易维护,比较安全的.同时,一旦使用继承,就应该提供完备的文档说明.

使用复合方式,直接在类中增加私有域,包含原本的父类对象,当需要调用时原本父类的方法时,显然直接调用这个对象就OK,不耽搁.
包装器模式.但是包装器模式缺点在于不适合回调框架的设计.

所以,只有当一个类真正的是一个类的子类,有本质上 "is-a" 的属性时,采用继承更合适.否则,不但没有利用继承的强大特性,
减少代码,提高重用,反而花费更多的时间去修BUG.接口继承和复合的方式,更有实践意义.
